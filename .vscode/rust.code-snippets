{
	"Combination": {
	  "prefix": "!comb",
	  "body": [
      "pub struct Combination {",
      "    fact: Vec<Mint>,",
      "    ifact: Vec<Mint>,",
      "}",
      "",
      "impl Combination {",
      "    pub fn new(n: usize) -> Self {",
      "        let mut fact: Vec<Mint> = vec![1.into(); n + 1];",
      "        let mut ifact: Vec<Mint> = vec![1.into(); n + 1];",
      "",
      "        for i in 1..=n {",
      "            fact[i] = fact[i - 1] * Mint::new(i as u32);",
      "        }",
      "",
      "        ifact[n] = fact[n].inv();",
      "",
      "        for i in (1..=n).rev() {",
      "            ifact[i - 1] = ifact[i] * Mint::new(i as u32);",
      "        }",
      "        Self { fact, ifact }",
      "    }",
      "",
      "    pub fn comb(&self, n: usize, k: usize) -> Mint {",
      "        if k > n {",
      "            Mint::new(0)",
      "        } else {",
      "            self.fact[n] * self.ifact[k] * self.ifact[n - k]",
      "        }",
      "    }",
      "}"
    ],
	  "description": "combination"
	},
  "Rational Number": {
    "prefix": "!ratio",
    "body": [
      "use std::cmp::Ordering;",
      "",
      "#[derive(Debug, Clone, Eq)]",
      "struct Rational {",
      "    numerator: i64,",
      "    denominator: i64,",
      "}",
      "",
      "impl Rational {",
      "    pub fn new(numerator: i64, denominator: i64) -> Self {",
      "        let mut denom = if denominator == 0 { 1 } else { denominator };",
      "        let mut num = numerator;",
      "        if denom < 0 {",
      "            num = -num;",
      "            denom = -denom;",
      "        }",
      "        use num::integer::gcd;",
      "        let g = gcd(num, denom);",
      "        Rational {",
      "            numerator: num / g,",
      "            denominator: denom / g,",
      "        }",
      "    }",
      "}",
      "",
      "impl PartialEq for Rational {",
      "    fn eq(&self, other: &Self) -> bool {",
      "        self.numerator == other.numerator && self.denominator == other.denominator",
      "    }",
      "}",
      "",
      "impl PartialOrd for Rational {",
      "    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {",
      "        (self.numerator as i128 * other.denominator as i128)",
      "            .partial_cmp(&(other.numerator as i128 * self.denominator as i128))",
      "    }",
      "}"
    ],
    "description": "Rational struct with PartialEq and PartialOrd implementations"
  },
    "Rolling Hash": {
    "prefix": "!roliha",
    "body": [
      "const MOD: u64 = (1u64 << 60) - 1;",
      "const BASE: u64 = 1_000_000_007;",
      "",
      "fn mod_add(a: u64, b: u64) -> u64 {",
      "    let res = a + b;",
      "    if res >= MOD {",
      "        res - MOD",
      "    } else {",
      "        res",
      "    }",
      "}",
      "",
      "fn mod_sub(a: u64, b: u64) -> u64 {",
      "    if a >= b {",
      "        a - b",
      "    } else {",
      "        MOD - (b - a)",
      "    }",
      "}",
      "",
      "fn mod_mul(a: u64, b: u64) -> u64 {",
      "    let z = a as u128 * b as u128;",
      "    let low = z & ((1u128 << 60) - 1);",
      "    let high = z >> 60;",
      "    let res = low + high;",
      "    if res >= MOD as u128 {",
      "        (res - MOD as u128) as u64",
      "    } else {",
      "        res as u64",
      "    }",
      "}",
      "",
      "struct RollingHash {",
      "    hash: Vec<u64>,",
      "    power: Vec<u64>,",
      "}",
      "",
      "impl RollingHash {",
      "    fn new(s: &[u8]) -> Self {",
      "        let n = s.len();",
      "        let mut hash = vec![0; n + 1];",
      "        let mut power = vec![1; n + 1];",
      "        for i in 0..n {",
      "            hash[i + 1] = mod_add(mod_mul(hash[i], BASE), s[i] as u64);",
      "            power[i + 1] = mod_mul(power[i], BASE);",
      "        }",
      "        Self { hash, power }",
      "    }",
      "",
      "    fn get(&self, l: usize, r: usize) -> u64 {",
      "        mod_sub(self.hash[r], mod_mul(self.hash[l], self.power[r - l]))",
      "    }",
      "}"
    ],
    "description": "Rolling Hash implementation using MOD = 2^60 - 1"
  },
   "LCA Struct with Binary Lifting": {
    "prefix": "!lca",
    "body": [
      "pub struct Lca<T> {",
      "    n: usize,",
      "    l: usize,",
      "    root: usize,",
      "    to: Vec<Vec<(usize, T)>>,",
      "    depth: Vec<usize>,",
      "    cost: Vec<T>,",
      "    parent: Vec<Vec<usize>>,",
      "}",
      "",
      "impl<T> Lca<T>",
      "where",
      "    T: Copy + Default + std::ops::Add<Output = T> + std::ops::Sub<Output = T>,",
      "{",
      "    pub fn new(n: usize) -> Self {",
      "        let l = (n as f64).log2().ceil() as usize;",
      "        Self {",
      "            n,",
      "            l,",
      "            root: 0,",
      "            to: vec![Vec::new(); n],",
      "            depth: vec![0; n],",
      "            cost: vec![T::default(); n],",
      "            parent: vec![vec![n; l + 1]; n],",
      "        }",
      "    }",
      "",
      "    pub fn add_edge(&mut self, a: usize, b: usize, c: T) {",
      "        self.to[a].push((b, c));",
      "        self.to[b].push((a, c));",
      "    }",
      "",
      "    pub fn init(&mut self, root: usize) {",
      "        self.root = root;",
      "        dfs_impl(",
      "            root,",
      "            0,",
      "            T::default(),",
      "            None,",
      "            &self.to,",
      "            &mut self.depth,",
      "            &mut self.cost,",
      "            &mut self.parent,",
      "        );",
      "        for i in 0..self.l {",
      "            for v in 0..self.n {",
      "                let mid = self.parent[v][i];",
      "                if mid < self.n {",
      "                    self.parent[v][i + 1] = self.parent[mid][i];",
      "                }",
      "            }",
      "        }",
      "    }",
      "",
      "    fn up(&self, mut v: usize, mut k: usize) -> usize {",
      "        for i in (0..=self.l).rev() {",
      "            if k >= (1 << i) {",
      "                v = self.parent[v][i];",
      "                k -= 1 << i;",
      "            }",
      "        }",
      "        v",
      "    }",
      "",
      "    pub fn query(&self, mut a: usize, mut b: usize) -> usize {",
      "        if self.depth[a] > self.depth[b] {",
      "            std::mem::swap(&mut a, &mut b);",
      "        }",
      "        b = self.up(b, self.depth[b] - self.depth[a]);",
      "        if a == b {",
      "            return a;",
      "        }",
      "        for i in (0..=self.l).rev() {",
      "            if self.parent[a][i] != self.parent[b][i] {",
      "                a = self.parent[a][i];",
      "                b = self.parent[b][i];",
      "            }",
      "        }",
      "        self.parent[a][0]",
      "    }",
      "",
      "    pub fn length(&self, a: usize, b: usize) -> usize {",
      "        let c = self.query(a, b);",
      "        self.depth[a] + self.depth[b] - 2 * self.depth[c]",
      "    }",
      "",
      "    pub fn dist(&self, a: usize, b: usize) -> T {",
      "        let c = self.query(a, b);",
      "        self.cost[a] + self.cost[b] - self.cost[c] - self.cost[c]",
      "    }",
      "}",
      "",
      "fn dfs_impl<T>(",
      "    v: usize,",
      "    d: usize,",
      "    c: T,",
      "    p: Option<usize>,",
      "    to: &Vec<Vec<(usize, T)>>,",
      "    depth: &mut Vec<usize>,",
      "    cost: &mut Vec<T>,",
      "    parent: &mut Vec<Vec<usize>>,",
      ") where",
      "    T: Copy + std::ops::Add<Output = T>,",
      "{",
      "    if let Some(par) = p {",
      "        parent[v][0] = par;",
      "    }",
      "    depth[v] = d;",
      "    cost[v] = c;",
      "",
      "    for &(u, w) in &to[v] {",
      "        if Some(u) == p {",
      "            continue;",
      "        }",
      "        dfs_impl(u, d + 1, c + w, Some(v), to, depth, cost, parent);",
      "    }",
      "}"
    ],
    "description": "Binary Lifting LCA with cost and length support"
  },
    "Sieve": {
    "prefix": "!sieve",
    "body": [
      "struct Sieve {",
      "    p: Vec<usize>,",
      "    is_prime: Vec<bool>,",
      "}",
      "impl Sieve {",
      "    fn new(n: usize) -> Self {",
      "        let mut p = vec![];",
      "        let mut is_prime = vec![true; n + 1];",
      "        for i in 2..=n {",
      "            if is_prime[i] {",
      "                p.push(i);",
      "                let mut now = i;",
      "                while now + i <= n {",
      "                    now += i;",
      "                    is_prime[now] = false;",
      "                }",
      "            }",
      "        }",
      "        Sieve { p, is_prime }",
      "    }",
      "}"
    ],
    "description": "Sieve of Eratosthenes implementation"
  }
}